{"ast":null,"code":"//Rest APIs for user authentication and registration\nimport jwt_decode from\"jwt-decode\";export var doLogin=function doLogin(email,password){//Note: we are returning promise so that we can resolve it by using appropriate data type like json or text\n//caller of the function should only be concerned with returned data on success or failure message\nvar promiseResolveRef=null;var promiseRejectRef=null;var promise=new Promise(function(resolve,reject){promiseResolveRef=resolve;promiseRejectRef=reject;});fetch('http://localhost:8080/api/auth/signin',{method:'POST',body:JSON.stringify({username:email,password:password}),headers:{'Content-type':'application/json; charset=UTF-8'}}).then(function(response){response.json().then(function(json){if(response.ok){//let token = response.headers.get(\"x-auth-token\");\nvar token=json.token;var decoded=jwt_decode(token);console.log(json);promiseResolveRef({username:json.email,accessToken:token,accessTokenTimeout:decoded.exp*1000,//convert to epoch\nroles:json.roles,userId:json.userId,response:response});}else{promiseRejectRef({reason:\"Server error occurred. Please try again.\",response:response});}}).catch(function(error){promiseRejectRef({reason:\"Bad Credentials. Please try again.\",response:error});});}).catch(function(err){promiseRejectRef({reason:\"Some error occurred. Please try again.\",response:err});});return promise;};export var doSignup=function doSignup(requestJson){//Note: we are returning promise so that we can resolve it by using appropriate data type like json or text\n//caller of the function should only be concerned with returned data on success or failure message\nvar promiseResolveRef=null;var promiseRejectRef=null;var promise=new Promise(function(resolve,reject){promiseResolveRef=resolve;promiseRejectRef=reject;});fetch('http://localhost:8080/api/auth/signup',{method:'POST',body:JSON.stringify(requestJson),headers:{'Content-type':'application/json; charset=UTF-8'}}).then(function(response){response.json().then(function(json){if(response.ok){promiseResolveRef({message:json.message,response:response});}else{var message=json.message;if(message===undefined||message===null){message=\"Server error occurred. Please try again.\";}promiseRejectRef({reason:message,response:response});}}).catch(function(err){promiseRejectRef({reason:\"Some error occurred. Please try again.\",response:err});});}).catch(function(err){promiseRejectRef({reason:\"Some error occurred. Please try again.\",response:err});});return promise;};","map":{"version":3,"names":["jwt_decode","doLogin","email","password","promiseResolveRef","promiseRejectRef","promise","Promise","resolve","reject","fetch","method","body","JSON","stringify","username","headers","then","response","json","ok","token","decoded","console","log","accessToken","accessTokenTimeout","exp","roles","userId","reason","catch","error","err","doSignup","requestJson","message","undefined"],"sources":["C:/Users/Home/Documents/UpGrad-Project/upgrad-eshop/frontend/src/api/userAuthAPIs.js"],"sourcesContent":["//Rest APIs for user authentication and registration\n\nimport jwt_decode from \"jwt-decode\";\n\nexport const doLogin = (email, password) => {\n\t//Note: we are returning promise so that we can resolve it by using appropriate data type like json or text\n\t//caller of the function should only be concerned with returned data on success or failure message\n\tlet promiseResolveRef = null;\n\tlet promiseRejectRef = null;\n\tlet promise = new Promise((resolve, reject) => {\n\t\tpromiseResolveRef = resolve;\n\t\tpromiseRejectRef = reject;\n\t});\n\tfetch('http://localhost:8080/api/auth/signin', {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify({\n\t\t\tusername: email,\n\t\t\tpassword: password,\n\t\t}),\n\t\theaders: {\n\t\t\t'Content-type': 'application/json; charset=UTF-8',\n\t\t},\n\t}).then((response) => {\n\t\tresponse.json().then((json) => {\n\t\t\tif(response.ok) {\n\t\t\t\t//let token = response.headers.get(\"x-auth-token\");\n\t\t\t\tlet token = json.token;\n\t\t\t\tlet decoded = jwt_decode(token);\n\t\t\t\tconsole.log(json);\n\t\t\t\tpromiseResolveRef({\n\t\t\t\t\tusername: json.email,\n\t\t\t\t\taccessToken: token,\n\t\t\t\t\taccessTokenTimeout: decoded.exp * 1000, //convert to epoch\n\t\t\t\t\troles: json.roles,\n\t\t\t\t\tuserId: json.userId,\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tpromiseRejectRef({\n\t\t\t\t\treason: \"Server error occurred. Please try again.\",\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t}\n\t\t}).catch((error) => {\n\t\t\tpromiseRejectRef({\n\t\t\t\treason: \"Bad Credentials. Please try again.\",\n\t\t\t\tresponse: error,\n\t\t\t});\n\t\t});\n\t}).catch((err) => {\n\t\tpromiseRejectRef({\n\t\t\treason: \"Some error occurred. Please try again.\",\n\t\t\tresponse: err,\n\t\t});\n\t});\n\treturn promise;\n};\n\nexport const doSignup = (requestJson) => {\n\t//Note: we are returning promise so that we can resolve it by using appropriate data type like json or text\n\t//caller of the function should only be concerned with returned data on success or failure message\n\tlet promiseResolveRef = null;\n\tlet promiseRejectRef = null;\n\tlet promise = new Promise((resolve, reject) => {\n\t\tpromiseResolveRef = resolve;\n\t\tpromiseRejectRef = reject;\n\t});\n\t\n\tfetch('http://localhost:8080/api/auth/signup', {\n\t\tmethod: 'POST',\n\t\tbody: JSON.stringify(requestJson),\n\t\theaders: {\n\t\t\t'Content-type': 'application/json; charset=UTF-8',\n\t\t},\n\t}).then((response) => {\n\t\tresponse.json().then((json) => {\n\t\t\tif(response.ok) {\n\t\t\t\tpromiseResolveRef({\n\t\t\t\t\tmessage: json.message,\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet message = json.message;\n\t\t\t\tif(message === undefined || message === null) {\n\t\t\t\t\tmessage = \"Server error occurred. Please try again.\";\n\t\t\t\t}\n\t\t\t\tpromiseRejectRef({\n\t\t\t\t\treason: message,\n\t\t\t\t\tresponse: response,\n\t\t\t\t});\n\t\t\t}\n\t\t}).catch((err) => {\n\t\t\tpromiseRejectRef({\n\t\t\t\treason: \"Some error occurred. Please try again.\",\n\t\t\t\tresponse: err,\n\t\t\t});\n\t\t});\n\t}).catch((err) => {\n\t\tpromiseRejectRef({\n\t\t\treason: \"Some error occurred. Please try again.\",\n\t\t\tresponse: err,\n\t\t});\n\t});\n\treturn promise;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}